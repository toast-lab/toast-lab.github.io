
<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Lab 9 - Computer Architecture I - ShanghaiTech University</title>
<link rel="shortcut icon" type="image/png" href="../../favicon.ico">

<style type="text/css">
code {background-color: #ddeeff; color: #000000;}
kbd {background-color: #ddeeff; color: #000000;}
.new {background-color: #ffff00; color: #000000;}

div.checkoff {
  background:#eeeee0;
  padding:0.5em 1.5em 0.5em 1.5em;
  border-radius:1em;
  border:1px solid #ddd;
}

pre {
  background:#adc384;
  padding:0.5em 1.5em 0.5em 1.5em;
/*   border-radius:1em; */
  border:1px solid #ddd;
}


</style>
<link rel="stylesheet" type="text/css" href="../style.css">

</head>
<body>
<header>
<h2>Lab 9</h2>
</header>
<a href="../../">Computer Architecture I</a> <a href="http://www.shanghaitech.edu.cn">ShanghaiTech University</a><br>
<a href="../8">Lab 8</a> Lab 9 <a href="../10">Lab 10</a>

<div class="content">

<h2>Setup</h2>
<p>Download <a href="../../../19s/labs/10/Makefile" download>Makefile</a>, <a href="../../../19s/labs/10/sseTest.c" download>sseTest.c</a> and <a href="../../../19s/labs/10/sum.c" download>sum.c</a> to an appropriate location in your home directory.</p>

<p>Note that we are using SSE and SSE2 in this lab, since they are enabled by default in GCC on x86-64 platforms. If your CPU does not support SSE and SSE2 (which is very not likely), try to switch to one that supports.</p>

<h2>Exercises</h2>
<h3>Exercise 1: Familiarize Yourself</h3>
<p>Given the large number of available SIMD intrinsics we want you to learn how to find the ones that you'll need in your application.</p>

<p>Open <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">Intel Intrinsics Guide</a>. Do your best to interpret the new syntax and terminology.  Find the 128-bit intrinsics for the following SIMD operations (one for each):</p>
<ul>
	<li>Four floating point divisions in single precision (i.e. <tt>float</tt>)</li>
	<li>Sixteen max operations over signed 8-bit integers (i.e. <tt>char</tt>)</li>
	<li>Arithmetic shift right of eight signed 16-bit integers (i.e. <tt>short</tt>)</li>
</ul>

<div class='checkoff'>
<h4>Checkoff</h4> 
<ul>
	<li>Record these intrinsics in a text file to show your TA.</li>
</ul>
</div>

<h3>Exercise 2: Reading SIMD Code</h3>
<p>In this exercise you will consider the vectorization of 2-by-2 matrix multiplication in double precision:</p>
<p><img src="../../../19s/labs/10/matmul.png"></p>
<p>This accounts to the following arithmetic operations:</p>
 
<pre>
    C[0] += A[0]*B[0] + A[2]*B[1];
    C[1] += A[1]*B[0] + A[3]*B[1];
    C[2] += A[0]*B[2] + A[2]*B[3];
    C[3] += A[1]*B[2] + A[3]*B[3];
</pre>
 
<p>You are given the code <tt>sseTest.c</tt> that implements these operations in a SIMD manner.<br>The following intrinsics are used:</p>

<table border=1  cellspacing=0>
  <tr>
    <td><tt>__m128d _mm_loadu_pd( double *p )</tt></td>
    <td>returns vector (p[0], p[1])</td>
  </tr>
  <tr>
    <td><tt>__m128d _mm_load1_pd( double *p )</tt></td>
    <td>returns vector (p[0], p[0])</td>
  </tr>
  <tr>
    <td><tt>__m128d _mm_add_pd( __m128d a, __m128d b )</tt></td>
    <td>returns vector (a<sub>0</sub>+b<sub>0</sub>, a<sub>1</sub>+b<sub>1</sub>)</td>
  </tr>
  <tr>
    <td><tt>__m128d _mm_mul_pd( __m128d a, __m128d b )</tt></td>
    <td>returns vector (a<sub>0</sub>b<sub>0</sub>, a<sub>1</sub>b<sub>1</sub>)</td>
  </tr>
  <tr>
    <td><tt>void _mm_storeu_pd( double *p, __m128d a )</tt></td>
    <td>stores p[0]=a<sub>0</sub>, p[1]=a<sub>1</sub></td>
  </tr>
</table> 

<p>Compile sseTest.c into x86 assembly by running:</p>
<pre class='output'>
<span class='input'>make sseTest.s</span><span style="color:#666666;"></span>
</pre>

<p><b>Find the for-loop in <tt>sseTest.s</tt> and identify what each intrinsic is compiled into.</b> Does the loop actually exist? Comment the loop so that your TA can see that you understand the code.</p>

<div class='checkoff'>
<h4>Checkoff</h4> 
<ul>
	<li>Show your commented code to your TA and explain the for-loop.</li>
</ul>
</div>

<h3>Exercise 3: Writing SIMD Code</h3>
<p>For Exercise 3, you will vectorize/SIMDize the following code to achieve approximately 4x speedup over the naive implementation shown here:

<pre>
   static int sum_naive(int n, int *a)
   {
      int sum = 0;
      for (int i = 0; i &lt; n; i++)
      {
         sum += a[i];
      }
      return sum;
   }
</pre>

<p>You might find the following intrinsics useful:</p>
<table border=1  cellspacing=0>
  <tr>
    <td><tt>__m128i _mm_setzero_si128( )</tt></td>
    <td>returns 128-bit zero vector</td>
  </tr>
  <tr>
    <td><tt>__m128i _mm_loadu_si128( __m128i *p )</tt></td>
    <td>returns 128-bit vector stored at pointer p</td>
  </tr>
  <tr>
    <td><tt>__m128i _mm_add_epi32( __m128i a, __m128i b )</tt></td>
    <td>returns vector (a<sub>0</sub>+b<sub>0</sub>, a<sub>1</sub>+b<sub>1</sub>, a<sub>2</sub>+b<sub>2</sub>, a<sub>3</sub>+b<sub>3</sub>)</td>
  </tr>
  <tr>
    <td><tt>void _mm_storeu_si128( __m128i *p, __m128i a )</tt></td>
    <td>stores 128-bit vector a at pointer p</td>
  </tr>
</table> 

<p>Start with <tt>sum.c</tt>. Use SSE instrinsics to implement the <tt>sum_vectorized()</tt> 
function.</p>

<p>To compile your code, run the following command:</p>
<pre class='output'>
<span class='input'>make sum</span></pre>

<div class='checkoff'>
<h4>Checkoff</h4> 
<ul>
	<li>Show your TA your working code and performance improvement.</li>
</ul>
</div>

<h3>Exercise 4: Loop Unrolling</h3>
<p>Happily, you can obtain even more performance improvement!
Carefully unroll the SIMD vector sum code that you created in the previous exercise.
This should get you about a factor of 2 further increase in performance.
As an example of loop unrolling, consider the supplied function <tt>sum_unrolled()</tt>:

<pre>
   <span class="keyword">static int sum_unrolled(int n, int *a)
   </span>{<span class="keyword">
      int sum = 0;

      // unrolled loop
      for (int i = 0; i &lt; n / 4 * 4; i += 4)
      </span>{<span class="keyword">
         sum += a[i+0];
         sum += a[i+1];
         sum += a[i+2];
         sum += a[i+3];
      </span>}<span class="keyword">

      // tail case
      for (int i = n / 4 * 4; i &lt; n; i++)
      </span>{<span class="keyword">
         sum += a[i];
      </span>}<span class="keyword">

      return sum;
   </span>}
</pre>

<p>Also, feel free to check out Wikipedia's article on <a href="http://en.wikipedia.org/wiki/Loop_unrolling">loop unrolling</a> for more information. 

<p>Within <tt>sum.c</tt>, <b>copy your <tt>sum_vectorized()</tt> code into <tt>sum_vectorized_unrolled()</tt> and unroll it four times</b>.</p>

<p>To compile your code, run the following command:</p>
<pre class='output'>
<span class='input'>make sum</span><span style="color:#666666;"></span>
</pre>

<div class='checkoff'>
<h4>Checkoff:</h4> 
<ul>
	<li>Show your TA the unrolled implementation and performance improvement.</li>
</ul>
</div>

<h3>Exercise 5: Switch on Compiler Optimization</h3>
<p>Modify the Makefile to activiate the compiler optimization (e.g. -O2)

<p>To compile your code, run the following command:</p>
<pre class='output'>
<span class='input'>make sum</span><span style="color:#666666;"></span>
</pre>

<div class='checkoff'>
<h4>Checkoff:</h4> 
<ul>
  <li>Show your TA the performance of the compiler optimized code. Explain the results.</li>
</ul>
</div>

<footer>
<hr style="clear: both;"/>
<div style="float:left">
<address>
Schwertfeger, S&ouml;ren &lt;<code>soerensch</code> AT <code>shanghaitech.edu.cn</code>&gt;
</address>
<address>
Chundong Wang &lt;<code>wangchd</code> AT <code>shanghaitech.edu.cn</code>&gt;
</address>
Modeled after UC Berkeley's CS61C.<br>
Last modified: <time datetime="2020-05-01">2020-05-01</time>
</div>

</footer>
</body>
</html>
